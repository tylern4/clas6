///////////////////////////////////////////////////////
//
// plotResiVsLayer.cc
//
// This file runs over the root files generated by the 
// user_align program (hbook files are actually created
// and then converted to root) and produces plots 
// of residual vs. layer for each sector for three
// different angular ranges of the tracks. 
//
// Matt Bellis
// 12/15/05
//
///////////////////////////////////////////////////////
using namespace std;
#include<cstdlib>
#include<unistd.h>
#include<iostream>
#include<fstream>
#include<string>
#include"TTree.h"
#include"TFile.h"
#include"TMath.h"
#include"TH1.h"
#include"TH2.h"
#include"TF1.h"
#include"TCut.h"
#include"TCanvas.h"
#include"TGraph.h"
#include "TClass.h"
#include "TStyle.h"
#include "TPaveLabel.h"
#include "TLegend.h"
#include "TLine.h"

#define PI TMath::Pi()
#define TWOPI 2.0*TMath::Pi()
#define DEG2RAD 2.0*TMath::Pi()/360.0

void PrintOptions(const char *name);

int main(int argc, char **argv)
{

  // Set some root style stuff
  gStyle->SetStatW(0.30);
  gStyle->SetStatH(0.20);
  gStyle->SetStatFont(40);

  gStyle->SetTitleW(0.60);
  gStyle->SetTitleH(0.10);
  gStyle->SetTitleFont(40);

  gStyle->SetTitleSize(0.07,"X");
  gStyle->SetTitleFont(42);
  gStyle->SetTitleSize(0.07,"Y");
  gStyle->SetLabelSize(0.05,"X");

  gStyle->SetOptStat(0);

  gStyle->SetPalette(1,0);
  gStyle->SetPadBottomMargin(0.15);
  gStyle->SetPadLeftMargin(0.15);
  gStyle->SetPadRightMargin(0.15);

  int numcan = 3; // 3 canvases
  char name[256];
  char command[256];
  int ntrack;
  int sector[16];
  float calcdoca[16][36];
  float fitdoca[16][36];
  short int wire[16][36];
  int layer[16][36];
  float theta[16];

  int c;
  extern char *optarg;
  extern int optind;
  int verbose = 0;
  char *progName = argv[0];

  char *pass = "0000";

  if(argc == 1)
  {
    PrintOptions(progName);
    return 0;
  }
  else{
    while((c = getopt(argc,argv,"hp:v")) != -1){
      switch(c){
        case 'h':
          PrintOptions(progName);
          break;
        case 'v':
          verbose++;
          break;
        case 'p':
          pass = optarg;
          cerr << "Processing for " << pass << endl;
          break;
        default:
          PrintOptions(progName);
          return 0;
          break;
      }
    }
  }

  // Create the canvases
  TCanvas *can[numcan];
  for(int i=0;i<numcan;i++)
  {
    sprintf(name,"can%d",i);
    can[i] = new TCanvas(name,"",10+10*i, 10+10*i, 600, 900);
    can[i]->SetFillColor(0);
    if(1) can[i]->Divide(2,3);
  }

  // Declare the root file to be generated by this program
  // This will store the histograms we generate and the file
  // will be labeled by the name that we pass in as the "pass"
  char outFile[256];
  sprintf(outFile,"%s.ResiVsLayer.root",pass);
  TROOT simple("simple","");
  TFile rfile(outFile,"RECREATE");

  TH2F* hskew[24];

  for(int i=0;i<24;i++)
  {
    sprintf(name,"hskew%d",i);
    hskew[i] = new TH2F(name,"",400,-0.5,0.5, 36,0.5,36.5);
    hskew[i]->SetTitle("");
    hskew[i]->SetNdivisions(8);
    hskew[i]->GetXaxis()->CenterTitle();
    hskew[i]->GetXaxis()->SetTitleOffset(1.10);
    hskew[i]->GetXaxis()->SetTitleFont(42);
    hskew[i]->GetXaxis()->SetTitle("residual");
    hskew[i]->GetYaxis()->SetTitleOffset(1.1);
    hskew[i]->GetYaxis()->SetTitleFont(42);
    hskew[i]->GetYaxis()->CenterTitle();
    hskew[i]->GetYaxis()->SetTitle("layer");
    hskew[i]->SetFillColor(33);
  }

  // Declare a few more ROOT objects
  TPaveLabel *lab[24];
  TCut cut;
  TTree *tree;

  // Loop over the list of root files
  for(int iarg = optind; iarg < argc; ++iarg)
  {
    cerr << "Processing file: " << argv[iarg] << endl;

    TFile f(argv[iarg]);
    tree = (TTree*)f.Get("ALIGN/h50");

    // Grab some branches off the tree that we will 
    // wind up plotting
    tree->SetBranchAddress("ntrack",&ntrack);
    tree->SetBranchAddress("sector",&sector);
    tree->SetBranchAddress("calcdoca",&calcdoca);
    tree->SetBranchAddress("fitdoca",&fitdoca);
    tree->SetBranchAddress("wire",&wire);
    tree->SetBranchAddress("layer",&layer);
    tree->SetBranchAddress("theta",&theta);

    int max = 0;
    int angle;

    int nentries = int (tree->GetEntriesFast ());
    cerr << "nentries: " << nentries << endl;

    // Loop over the entries in the tree
    for (int i=0; i < nentries; i++)
    {

      if (i % 100 == 0) cerr << i << "\r";

      tree->GetEntry (i);
      for(int j=0;j<ntrack;j++) // Loop over the tracks for this event
      {
        // Grab tracks between 8 and 115 degrees
        if(theta[j]>8*DEG2RAD && theta[j]<115*DEG2RAD)
        {
          angle = 3;
          if(theta[j]>8*DEG2RAD && theta[j]<20*DEG2RAD)        angle = 0; // 8-20
          else if(theta[j]>40*DEG2RAD && theta[j]<65*DEG2RAD)  angle = 1; // 40-65
          else if(theta[j]>75*DEG2RAD && theta[j]<115*DEG2RAD) angle = 2; // 75-115
          for(int k=0;k<36;k++) // loop over the layers
          {
            if(wire[j][k]>0) // if there's a good hit on the wire, fill the histogram
            {
              hskew[6*angle + sector[j]-1]->Fill(fitdoca[j][k]-calcdoca[j][k],k+1);
            }
          }
        }
      }
    }
  }

  // Draw the histograms on our canvases
  for(int angle=0;angle<3;angle++)
  {
    for(int sec=0;sec<6;sec++)
    {
      can[angle]->cd(sec+1);
      gPad->SetLogz(); // Log scale
      if(angle==0)sprintf(command,"Sec: %d   8< #theta <20 - %s",sec+1,pass);
      else if(angle==1)sprintf(command,"Sec: %d   40< #theta <65 - %s",sec+1,pass);
      else if(angle==2)sprintf(command,"Sec: %d   75< #theta <115 - %s",sec+1,pass);
      hskew[6*angle + sec]->Draw("colz");
      // Draw the labels
      lab[6*angle + sec] = new TPaveLabel(-0.4,36,0.55,40,command);
      lab[6*angle + sec]->Draw();
    }
  }


  // Print the histograms to .eps files
  for(int i=0;i<numcan;i++)
  {
    sprintf(name,"canvas%d.%s.ResiVsLayer.eps",i,pass);
    can[i]->SaveAs(name);
  }

  // Write and close our histogram file
  rfile.Write();
  rfile.Close();

  return 0;

}


//_____________________________________________________________________________
//
void PrintOptions(const char *name) {
  // Print options to the screen.
  cerr << endl;
  cerr << "Usage:" << name << " -p <string> ... inFile1 inFile2 ... " << endl;
  cerr << endl;
  cerr << "\t-t<string> The string will designate for which pass this is." << endl;
  cerr << "\t\tThis string will be used as labels on the plots, as well as" << endl;
  cerr << "\t\tfor the names for the .root file and .eps files produced." << endl;
  cerr << "\t-v  Verbose mode" << endl;
  cerr << "\t-h  Print this message." << endl;
  cerr << endl;
}
