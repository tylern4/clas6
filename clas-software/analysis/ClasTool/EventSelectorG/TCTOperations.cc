// Autogenerated Class (Source File)
// Author : G.Gavalian
// Date   : Mon Jul  9 16:57:07 EDT 2007
//

#include "TCTOperations.h"



ClassImp(TCTOperations)


TCTOperations::TCTOperations (){

}

TCTOperations::~TCTOperations (){

}

//-----------------
//-----------------
//-----------------
TLorentzVector  TCTOperations::GetOperV(const char *oper, TLorentzVector *v1)
{
  TString  fOper = oper;
  TLorentzVector  fRes(0.,0.,0.,0.);
  int  op_flag = 0;
  if(fOper.CompareTo("ADD")==0){ fRes = v1[0] + v1[1]; op_flag = 1;}
  if(fOper.CompareTo("SUB")==0){ fRes = v1[0] - v1[1]; op_flag = 1;}
  if(fOper.CompareTo("VFRAME3")==0){ fRes = func_v_unboost_lvect_dir(v1[0],v1[1],v1[2]); op_flag = 1;}

  if(op_flag==0) printf("TCTOperations::GetOperV:: ERROR . Unknown operation (%s)\n ",oper);

  return fRes;
}

Double_t        TCTOperations::GetOper(const char *oper, TLorentzVector *v1)
{
  double  fRes=0.;
  
  return  fRes;
}

TLorentzVector  TCTOperations::func_v_unboost_lvect_dir( TLorentzVector v1,TLorentzVector v2, TLorentzVector v3)
{
  TLorentzVector  vB_l = v1;
  TLorentzVector  vZ_l = v2;
  TLorentzVector  vV_l = v3;
  double   phi_rot_z = -vB_l.Vect().Phi();
  vZ_l.RotateZ(phi_rot_z);
  vV_l.RotateZ(phi_rot_z);
  vB_l.RotateZ(phi_rot_z);
  TVector3  v3boost(-vB_l.Px()/vB_l.E(),-vB_l.Py()/vB_l.E(),-vB_l.Pz()/vB_l.E());
  vZ_l.Boost(v3boost);
  vV_l.Boost(v3boost);
  double rot_phi_y = vZ_l.Theta();
  vV_l.RotateY(rot_phi_y);
  return vV_l;
}

 
TLorentzVector  TCTOperations::func_v_boost_lvect(   TLorentzVector v1,TLorentzVector v2)
{
  TLorentzVector vRes;
  return vRes;
}
TLorentzVector  TCTOperations::func_v_unboost_lvect( TLorentzVector v1,TLorentzVector v2)
{
  TLorentzVector vRes;
  return vRes;
}


TVector3        TCTOperations::func_ray_intersect( TVector3 v1, TVector3 p1, 
				 TVector3 v2, TVector3 p2, Double_t *dist ) 
{
  //
  // Find the mid point on the line segment that connects the
  // two lines (tracks) at the point of closest approach.
  //
  //  Modified funtion from Maurik
  //
  Double_t R1 = 0;
  TVector3 diff = (v1) - (v2);

  // Phat1, Phat2 are the normalized P vectors, which
  // is just the cosine terms.
  // R=Phat1 dot Phat2
  TVector3 p1unit = p1.Unit();
  TVector3 p2unit = p2.Unit();

  Double_t R = p1unit.Dot(p2unit);

  if( R >= 1. ) {
    printf("Parallel %f\n",R);
    //    cout << "Parallel " << R << endl;
    return(-1);
  } else {
    R1 = 1 / ( 1- R*R );
  }

  TVector3 RP21 = p2unit*R - p1unit;
  TVector3 RP12 = p2unit - p1unit*R;
  Double_t DOT21 = diff.Dot(RP21);
  Double_t DOT12 = diff.Dot(RP12);
//
// The M1 (2) vectors point to the closest point on
// track 1 (2) to track 2 (1)
// R1*DOT21 is equal to "alpha"
// R1*DOT12 is equal to "beta"
//

  TVector3 M1 = v1 + p1unit*R1*DOT21;
  TVector3 M2 = v2 + p2unit*R1*DOT12;

  TVector3 diff1 = M2 - M1;
  (*dist) = diff1.Mag() ;

  TVector3 MidPoint = ( M1 + M2 ) * 0.5;

  return  MidPoint;

}
