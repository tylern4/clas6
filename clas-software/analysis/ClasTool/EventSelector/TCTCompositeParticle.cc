// Autogenerated Class (Source File)
// Author : G.Gavalian
// Date   : Fri Sep 28 15:34:08 EDT 2007
//

#include "TCTCompositeParticle.h"



ClassImp(TCTCompositeParticle)

  TCTCompositeParticle::TCTCompositeParticle (const char *__pname,const char *__foperator, double __mass,double pid_cut)
{
  SetName(__pname);
  fOperator = __foperator;
  fPartMassCut = pid_cut;
  fPartMass = __mass;
}

  TCTCompositeParticle::TCTCompositeParticle (const char *__pname,int __p1, int __p2, double __mass,double pid_cut){
  SetName(__pname);
  
  SetPartDep(__p1,__p2);
  fPartMassCut = pid_cut;
  fPartMass = __mass;
}
TCTCompositeParticle::TCTCompositeParticle (){

}

TCTCompositeParticle::~TCTCompositeParticle (){

}

//-----------------
//-----------------
//-----------------
Int_t           TCTCompositeParticle::GetStatus()
{
  if(fabs(fPartVector.M()-fPartMass)>fPartMassCut) return -1;
  return 0;
}

void       TCTCompositeParticle::Construct(TCTParticle __p1, TCTParticle __p2)
{
  //  printf("construct %f %f \n",__p1.GetV().P(),__p2.GetV().P());
  fPartVector = __p1.GetV()+__p2.GetV();
  fPartVertex = FindNeutralVtx(__p1.GetVert(),__p1.GetV().Vect(),
					  __p2.GetVert(),__p2.GetV().Vect(),
					  &fPartDOCA);

  TVector3  fv_dist = fPartVertex - fInterVertex;
  fPartDistance = fv_dist.Mag();
  double    angle = fv_dist.Dot(fPartVector.Vect())/(fv_dist.Mag()*fPartVector.Vect().Mag());;
  fPartColiniarity = angle;
}


Double_t        TCTCompositeParticle::Get(const char *var)
{
  TString  str_var(var);
  double   var_d = 0.;
  if(str_var.CompareTo("Px")==0) var_d = fPartVector.Px();
  if(str_var.CompareTo("Py")==0) var_d = fPartVector.Py();
  if(str_var.CompareTo("Pz")==0) var_d = fPartVector.Pz();
  if(str_var.CompareTo("M2")==0) var_d = fPartVector.M2();
  if(str_var.CompareTo("M") ==0) var_d = fPartVector.M();

  if(str_var.CompareTo("Vx")==0) var_d = fPartVertex.X();
  if(str_var.CompareTo("Vy")==0) var_d = fPartVertex.Y();
  if(str_var.CompareTo("Vz")==0) var_d = fPartVertex.Z();
  if(str_var.CompareTo("DOCA")==0) var_d = GetDOCA();
  if(str_var.CompareTo("DIST")==0) var_d = fPartDistance;
  if(str_var.CompareTo("COLIN")==0) var_d = fPartColiniarity;
  
  //  if(str_var.CompareTo("Vy")) var_d = fPARTBank.GetPx();
  return  var_d;
}

int        TCTCompositeParticle::GetP(int __indx)
{
  const char *__str = fOperator.Data();
  int   real_idx = __indx*2;
  int  _idx = (int) (__str[real_idx] - '0');
  return _idx;
}
int        TCTCompositeParticle::GetNPart()
{
  int n_part = (fOperator.Length()+1)/2;
  if(n_part<0) return 0;
  return n_part;
}

int        TCTCompositeParticle::GetSign(int __indx)
{
  if(__indx==0) return 1;
  const char *__str    = fOperator.Data();
  int   real_idx  = __indx*2-1;
  char  __sign    =  (__str[real_idx]);
  
  if(__sign=='-') return -1;
  return +1;
}


TVector3        TCTCompositeParticle::FindNeutralVtx( TVector3 v1, TVector3 p1, 
				 TVector3 v2, TVector3 p2, Double_t *dist ) 
{
  //
  // Find the mid point on the line segment that connects the
  // two lines (tracks) at the point of closest approach.
  //
  //  Modified funtion from Maurik
  //
  Double_t R1 = 0;
  TVector3 diff = (v1) - (v2);

  // Phat1, Phat2 are the normalized P vectors, which
  // is just the cosine terms.
  // R=Phat1 dot Phat2
  TVector3 p1unit = p1.Unit();
  TVector3 p2unit = p2.Unit();

  Double_t R = p1unit.Dot(p2unit);

  if( R >= 1. ) {
    cout << "Parallel " << R << endl;
    return(-1);
  } else {
    R1 = 1 / ( 1- R*R );
  }

  TVector3 RP21 = p2unit*R - p1unit;
  TVector3 RP12 = p2unit - p1unit*R;

  Double_t DOT21 = diff.Dot(RP21);
  Double_t DOT12 = diff.Dot(RP12);
//
// The M1 (2) vectors point to the closest point on
// track 1 (2) to track 2 (1)
// R1*DOT21 is equal to "alpha"
// R1*DOT12 is equal to "beta"
//

  TVector3 M1 = v1 + p1unit*R1*DOT21;
  TVector3 M2 = v2 + p2unit*R1*DOT12;

  TVector3 diff1 = M2 - M1;
  (*dist) = diff1.Mag() ;

  TVector3 MidPoint = ( M1 + M2 ) * 0.5;

  return  MidPoint;

}

