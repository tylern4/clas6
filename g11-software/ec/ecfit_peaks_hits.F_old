      SUBROUTINE EcFit_peaks_hits(layer,sector)
*...............................................................
*- Tries to construct hits from peaks on the 3 edges
*
*inputs: layer           Ec layer  ( inner or  outer)
*         sector         CLAS sector (1: MAXsectors)
*
*- modified Aug.1, 1994 to weight peak assignments on average of
*- of lowest 2 of 3 peaks. KBB
*- modified Feb.21, 1994  Z.Li
*
*...............................................................
      IMPLICIT NONE
      SAVE
c rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rsc rcs rcs rcs
c rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rsc rcs rcs rcs
c                                                                         rcs
c  RCS information:                                                       rcs
c                                                                         rcs
      CHARACTER*132  CFILE, CREVIS, CSTATE, CDATE, CAUTHO, CRCSID
      PARAMETER (CFILE = '$RCSfile: ecfit_peaks_hits.F_old,v $') 
      PARAMETER (CREVIS = '$Revision: 1.1 $')
      PARAMETER (CSTATE = '$State: Exp $')
      PARAMETER (CDATE = '$Date: 1997/10/23 20:50:26 $')
      PARAMETER (CAUTHO = '$Author: boiarino $')
      DATA CRCSID/ 
     1'$Id: ecfit_peaks_hits.F_old,v 1.1 1997/10/23 20:50:26 boiarino Exp $'
     2/ 
c  Module information: 
      CHARACTER*(*)  CRNAME, CRAUTH
      CHARACTER*100  CRMESS
      PARAMETER (CRNAME='ecfit_peaks_hits')                                   
      PARAMETER (CRAUTH='Zhujun Li')
c                                                                         rcs
c rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rsc rcs rcs rcs
c rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rcs rsc rcs rcs rcs
c
*
#include "Ec_general.PAR"
#include "EcStrip.CMN"
#include "ecgeom.inc"
#include "EcFit_general.CMN"
#include "EcFit_edge.CMN"
#include "ec_control.inc"
#include "EcCal.CMN"    
*                      !! EcCal.CMN and EcCal.DTE is the same except
*                         that in DTE the attenuation length is data
*                          and in CMN the attenuation length is in common
*
      integer layer,sector
      integer id,iterr
      real d( undefined: last_par)
      real ddu,ddv,ddw
      integer ith,axis,hit,L,s
*
      integer MAXpsble
      parameter (MAXpsble= 2* MAXhits)
*
      integer Npsble,edge,Nhit
      integer peakID,exclude
      real psble( Ec_i: last_par,MAXpsble)
      real possibleE(MAXpsble),lat
      integer psbleID( Ec_u: Ec_w,MAXpsble),ids(MAXpsble)
      integer peak( Ec_u: Ec_w),pid,pUid,pVid,pWid
      integer peak_Nhit( MAXpeaks, Ec_u: Ec_w)
      integer peak_hit(MAXpsble, MAXpeaks, Ec_u: Ec_w)
      real peak_assnd( MAXpeaks, Ec_u: Ec_w),psble_av(MAXpsble)
*
      EXTERNAL Ec_dalitz
      LOGICAL Ec_dalitz                !FUNCTION
      logical good,OK
      real spread,sum(ENERGY:DIM),attn,inv_attn,Npks,dst
      real RMS_spread,path( Ec_u: Ec_w)
      integer prj
*
***********************************************************
*- peaks have already been sorted by decreasing size; now make U,V,W
*- combinations
*
      L= layer                          !short form
      s= sector
      Npsble= 0                         !number possible hits
*
      iterr=1                      
*
      DO edge= Ec_U,Ec_W                      !clear assignments
        Do pid= 1,EcFit_Npeak(edge,L,s)
          peak_Nhit(pid,edge)= 0
          peak_assnd(pid,edge)= 0.
        EndDo
      ENDDO
*
      DO pUid= 1,EcFit_Npeak(Ec_U,L,s)
        peak(Ec_U)= pUid
        d(Ec_U)= EcFit_peak(DIST,peak(Ec_U),Ec_U,L,s)
        ddU= EcFit_peak(WIDTH,peak(Ec_U),Ec_U,L,s)
        Do pVID= 1,EcFit_Npeak(Ec_V,L,s)
          peak(EC_V)= pVid
          d(Ec_V)= EcFit_peak(DIST,peak(Ec_V),Ec_V,L,s)
          ddV= EcFit_peak(WIDTH,peak(Ec_V),Ec_V,L,s)
          do pWID= 1,EcFit_Npeak(Ec_W,L,s)
            peak(Ec_W)= pWid
            d(Ec_W)= EcFit_peak(DIST,peak(Ec_W),Ec_W,L,s)
            ddW= EcFit_peak(WIDTH,peak(Ec_W),Ec_W,L,s)
*
cStep            spread= (EcFit_peak(WIDTH,peak(Ec_U),Ec_U,L,s) +
cStep     &                   EcFit_peak(WIDTH,peak(Ec_V),Ec_V,L,s) +
cStep     &                   EcFit_peak(WIDTH,peak(Ec_W),Ec_W,L,s))*
cStep     &                   2.*SQRT(12.)
*
*
            good= Ec_dalitz(d(Ec_U),d(Ec_V),d(Ec_W),ddU,ddV,
     &            ddW,d(EC_I),d(EC_J),d(Ec_K),
     &            d(EC_dI),d(EC_dJ),RMS_spread,L,s,iterr)
*
            OK= Npsble.LT.MAXpsble
            If(good .and. .NOT.OK) Then
              print *,'too many possible hits'
              RETURN
            ENDIF
*
            IF(good) THEN
*
              Npsble= Npsble+1
*
              psble(Ec_I,Npsble)= d(Ec_I)
              psble(Ec_J,Npsble)= d(EC_J)
              psble(Ec_K,Npsble)= d(Ec_K)
              psble(WIDTH,Npsble)= RMS_spread
              psble(ENERGY,Npsble)= EcFit_peak(ENERGY,peak(Ec_U)
     &        ,Ec_U,L,s)+EcFit_peak(ENERGY,peak(Ec_V),Ec_V,L,s) 
     &          +EcFit_peak(ENERGY,peak(Ec_W),Ec_W,L,s)
              psble(DARK,Npsble)= EcFit_peak(DARK,peak(Ec_U),Ec_U,L,s) 
     &          +EcFit_peak(DARK,peak(Ec_V),Ec_V,L,s)
     &          +EcFit_peak(DARK,peak(Ec_W),Ec_W,L,s)
*
*- do NOT include attenuation effects at this stage
*
              psble_av(Npsble)= EcFit_peak(ENERGY,peak(Ec_U),Ec_U,L,s)
              exclude= Ec_U
              do edge= Ec_V,Ec_W
                IF(EcFit_peak(ENERGY,peak(edge),edge,L,s).GT.
     &                                     psble_av(Npsble)) Then
                  exclude= edge
                  psble_av(Npsble)= 
     &                    EcFit_peak(ENERGY,peak(edge),edge,L,s)
                ENDIF
              enddo
              do edge= Ec_U,Ec_W
                IF(edge.NE.exclude) THEN
                  psble_av(Npsble)= psble_av(Npsble) + 
     &                       EcFit_peak(ENERGY,peak(edge),edge,L,s)
                ENDIF
              enddo
*
*
              Do edge= Ec_U,Ec_W
*- store ID of peak(s) making up a possible hit
                psbleID(edge,Npsble)= peak(edge)
*
*- store ID&# of hit(s) that peak may belong to
                peak_Nhit(peak(edge),edge)=
     &               peak_Nhit(peak(edge),edge) + 1
                peak_hit(peak_Nhit(peak(edge),edge),peak(edge),edge)=
     &               Npsble
                peak_assnd(peak(edge),edge)=
     &               peak_assnd(peak(edge),edge) + psble_av(Npsble)
*
              EndDo
*
            ENDIF        !dalitz rule
*
          enddo
        EndDo
      ENDDO              !  end all peak loop
*
**************************************************************
*
      DO ith= 1,Npsble
        possibleE(ith)= psble(ENERGY,ith)
      ENDDO
*
*-sort by decreasing energy
      call EcGus_sort(Npsble,possibleE,ids)
*- pick out those above threshold
      Nhit= 0
      DO ith=1,Npsble
        If(possibleE(ids(ith)).lt.EcFitEdge_hit_threshold) go to 88 !above thre+
        Nhit= Nhit+1                                          !#
      ENDDO
*
88    continue
      Nhit= MIN(Nhit, MAXhits) !restrict space
*
      EcFit_Nhit(L,s)= Nhit             !total hits in this layer
*
      DO hit= 1,Nhit
        id= ids(hit)
*
        Do prj= Ec_I, Ec_k
          d(prj)= psble(prj,id)
        EndDo
*
        Do edge= Ec_U,Ec_W
*
*- peak on edge associated with hit in layer within a sector
          EcFit_hit_peak(edge,hit,L,s)= psbleID(edge,id)
*
*- fraction of peak assigned to hit (no attenuation corrections)
          EcFit_hit_fraction(edge,hit,L,s)=  psble_av(id)/
     &                     peak_assnd(psbleID(edge,id),edge)   !normalize
*
        EndDo
*
*
*
*        decide on a better interative assignment scheme later
*
*
*
        call Ec_ijk_xyz(d(Ec_I),d(Ec_J),d(Ec_K),d(Ec_X),d(Ec_Y),
     &           d(Ec_Z),s,iterr)
        Do prj= Ec_I,Ec_K                            !store geometrical location
          EcFit_hit(prj,hit,L,s)= d(prj)       !IJK
        EndDo
* temp need to adjust ec_general.par
        Do prj= Ec_x,Ec_z                            !store geometrical location
          EcFit_hit(prj,hit,L,s)= d(prj)       !XYZ 
        EndDo
*
*-find path to edge along a edge || to strips-
        call Ec_ij_path(d(Ec_I),d(Ec_J),path(Ec_U),path(Ec_V),
     &             path(Ec_W),L,s)
*
        Do prj= ENERGY,DIM
          sum(prj)= 0.
        EndDo
        Npks= 0.
        Do axis= Ec_U,Ec_W
*
          Npks= Npks + 1.
          peakID= psbleID(axis,id)
*
          dst= path(axis)
*
*-add attenuation corrections
c
cTYTYTYTYTY TYTYTYTYTY TYTYTYTYTY TYTYTYTYTY TYTYTYTYTY TYTYTYTYTY
         LAT=0.                                                    !
	do ith=1,EcFit_peak_Nstrip(peakID,axis,L,S)               !
         LAT=EcCal_atten
     & (EcFit_peak_strip(ith,PeakID,axis,layer,sector)                                                     !
     &,axis,L,s)+LAT
         enddo
c         
	LAT=LAT/float(EcFit_peak_Nstrip(peakID,axis,L,S))
c
cTYTYTYTYTY TYTYTYTYTY TYTYTYTYTY TYTYTYTYTY TYTYTYTYTY TYTYTYTYTY
cBUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG
c
c         
c          Lat= EcCal_atten(peakID,axis,L,S)

cBUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG  ! Fix this bug by TY
********************************************************************
          attn= exp(-dst/Lat)

          inv_attn= 1./attn
*
          sum(ENERGY)= sum(ENERGY) + EcFit_hit_fraction(axis,hit,L,s) *
     &         EcFit_peak(ENERGY,peakID,axis,L,s) * inv_attn
*
Cstep          sum(TIME)= sum(TIME) - speed_in_plastic*dst +
Cstep     &         EcFit_peak(TIME,peakID,axis,L,s)       !correction
          sum(TIME)= sum(TIME) +
     &         EcFit_peak(TIME,peakID,axis,L,s)       !for now
*
          sum(DARK)= sum(DARK) + EcFit_hit_fraction(axis,hit,L,s) *
     &         EcFit_peak(DARK,peakID,axis,L,s) * inv_attn
*
          sum(FEY)= sum(FEY) +
     &         EcFit_peak(FEY,peakID,axis,L,s)
*
          sum(DIM)= sum(DIM) +
     &         EcFit_peak(DIM,peakID,axis,L,s)
*
          sum(ATTEN)= sum(ATTEN) + attn
*
          sum(DIST)= sum(DIST) + dst
*
*              "-" due to axis*next<0
c          sum(WIDTH)= sum(WIDTH) - EcFit_peak(WIDTH,peakID,axis,L,s)/
c     &          Ec_unit(axis, Ec_next_axis(axis),s)
*
        EndDo
*
        Npks= MAX(Npks,1.)
        EcFit_hit(ENERGY,hit,L,s)= sum(ENERGY)
        EcFit_hit(TIME,hit,L,s)= sum(TIME)/Npks
c        EcFit_hit(WIDTH,hit,L,s)= sum(WIDTH)/Npks
        EcFit_hit(WIDTH,hit,L,s)=psble(WIDTH,hit)
        EcFit_hit(DARK,hit,L,s)= sum(DARK)     !measure of missing energy
        EcFit_hit(FEY,hit,L,s)= sum(FEY)/Npks  !av. hidden
        EcFit_hit(DIM,hit,L,s)= sum(DIM)       !total dimness
        EcFit_hit(DIST,hit,L,s)= sum(DIST)     !total proj.
        EcFit_hit(ATTEN,hit,L,s)= sum(ATTEN)/Npks      !av. atten.
*                                                        information content
*- add in quality/probablity estimates later
*        
      ENDDO
      RETURN
      END
