// Autogenerated Class (Source File)
// Author : G.Gavalian
// Date   : Tue Nov  6 14:04:17 EST 2007
//

#include "TCTGenParticle.h"



ClassImp(TCTGenParticle)


TCTGenParticle::TCTGenParticle (const char *name)
{
  Reset();
  SetName(name);
}

TCTGenParticle::TCTGenParticle (const char *name,int type,double mass)
{
  Reset();
  SetName(name);
  fPartPdgId   = type;
  fPartPdgMass = mass;
  fPartMass    = mass;
  fPartVector.SetPxPyPzE(0.,0.,0.,mass);
}
TCTGenParticle::TCTGenParticle (const char *name,const char *pdgname,int type,double mass)
{
  Reset();
  SetName(name);
  fPartPdgId   = type;
  fPartPdgMass = mass;
  fPartMass    = mass;
  fPartVector.SetPxPyPzE(0.,0.,0.,mass);
  fPartPdgName = pdgname;
}



TCTGenParticle::~TCTGenParticle (){

}

//-----------------
//-----------------
//-----------------
Double_t        TCTGenParticle::Get(const char *system)
{

  TString  str_var(system);
  
  double   var_d = 0.;
  if(str_var.CompareTo("Px")==0) return fPartVector.Px();
  if(str_var.CompareTo("Py")==0) return fPartVector.Py();
  if(str_var.CompareTo("Pz")==0) return fPartVector.Pz();
  if(str_var.CompareTo("P")==0) return fPartVector.P();
  if(str_var.CompareTo("M")==0) return fPartVector.M();
  if(str_var.CompareTo("M2")==0) return fPartVector.M2();
  if(str_var.CompareTo("Vx")==0) return fPartVertex.X();
  if(str_var.CompareTo("Vy")==0) return fPartVertex.Y();
  if(str_var.CompareTo("Vz")==0) return fPartVertex.Z();
  if(str_var.CompareTo("Phi")==0) return fPartVector.Phi();
  if(str_var.CompareTo("Theta")==0) return fPartVector.Theta();
  if(str_var.CompareTo("DOCA")==0) return fVectDoca;
  if(str_var.CompareTo("DIST")==0) return fVertexDistance;
  if(str_var.CompareTo("COLL")==0) return fVectColliniarity;

  printf("system [%s] was not found\n\n",str_var.Data());
  return 0.;
}

void TCTGenParticle::Reset()
{
  fPartStatus = -1;
  fPartPdgId  = 0;
  fPartMass    = 0.;
  fVectDoca   = -100.;
  fVertexDistance   = 100.;
  fVectColliniarity = 100.;
  fPartVector.SetPxPyPzE(0.,0.,0.,0.);
  fPartVertex.SetXYZ(0.,0.,0.);  
}

void  TCTGenParticle::Construct(TCTGenParticle *fPartBuff, Int_t n_part)
{
  printf("Info: Not implemented for Generic Class\n");
}

void  TCTGenParticle::SetInteractionVertex(TVector3 _iv)
{
  TVector3  v_con  = fPartVertex - _iv;
  fVertexDistance  = v_con.Mag();
  TVector3  v_part = fPartVector.Vect();
  fVectColliniarity = v_con.Dot(v_part)/(v_con.Mag()*v_part.Mag());
}

void TCTGenParticle::Print()
{
  printf("|%12s|%12d|%12.4f|%12.4f|%12.4f|\n",GetName(),fPartPdgId,fPartPdgMass,fPartVector.P(),fPartVector.M());
}

void TCTGenParticle::PrintVect()
{
  printf("[%12s] P(%9.5f , %9.5f , %9.5f)  Vrt (%9.5f , %9.5f , %9.5f)\n",GetName(),
	 fPartVector.Px(),fPartVector.Py(),fPartVector.Pz(),
	 fPartVertex.Px(),fPartVertex.Py(),fPartVertex.Pz());
}

TVector3        TCTGenParticle::MatchTracks( TVector3 v1, TVector3 p1, 
				 TVector3 v2, TVector3 p2, Double_t *dist ) 
{
  //
  // Find the mid point on the line segment that connects the
  // two lines (tracks) at the point of closest approach.
  //
  //  Modified funtion from Maurik
  //
  Double_t R1 = 0;
  TVector3 diff = (v1) - (v2);

  // Phat1, Phat2 are the normalized P vectors, which
  // is just the cosine terms.
  // R=Phat1 dot Phat2
  TVector3 p1unit = p1.Unit();
  TVector3 p2unit = p2.Unit();

  Double_t R = p1unit.Dot(p2unit);

  if( R >= 1. ) {
    //cout << "Parallel " << R << endl;
    printf("Parrallel %f\n",R);
    return(-1);
  } else {
    R1 = 1 / ( 1- R*R );
  }

  TVector3 RP21 = p2unit*R - p1unit;
  TVector3 RP12 = p2unit - p1unit*R;

  Double_t DOT21 = diff.Dot(RP21);
  Double_t DOT12 = diff.Dot(RP12);
//
// The M1 (2) vectors point to the closest point on
// track 1 (2) to track 2 (1)
// R1*DOT21 is equal to "alpha"
// R1*DOT12 is equal to "beta"
//

  TVector3 M1 = v1 + p1unit*R1*DOT21;
  TVector3 M2 = v2 + p2unit*R1*DOT12;

  TVector3 diff1 = M2 - M1;
  (*dist) = diff1.Mag() ;

  TVector3 MidPoint = ( M1 + M2 ) * 0.5;

  return  MidPoint;

}
